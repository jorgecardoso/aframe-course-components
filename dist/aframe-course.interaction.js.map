{"version":3,"file":"aframe-course.interaction.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;ACVA;;;;;AAKA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,CAAC;;;;;;UCjJD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;ACtBA,mBAAO,CAAC,2DAAiB","sources":["webpack://aframe-course-components/webpack/universalModuleDefinition","webpack://aframe-course-components/./src/interaction/new-event-set.js","webpack://aframe-course-components/webpack/bootstrap","webpack://aframe-course-components/./src/interaction/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","const EPS = 0.1;\n\n\n\n\nvar styleParser = AFRAME.utils.styleParser;\n\n/* global AFRAME */\n// AFRAME styleParse has one issue: it transforms hyphenated keys to camel-case.\n// This is a problem when those keys are component names, as A-Frame component\n// names often include hyphens, and are not converted internally to camel case.\n\n// To compensate for this, we post-process the data from the parser:\n// - analyze the first part of the string, represeting the component\n// - if translating this out of camel case to a dashed value gives\n//   a better match against known A-Frame components, then use the dashed value\n//   for the component name.\n\n// This solution is not 100% robust, but good enough for most circumstances.\n// - Will not handle component names that have a mix of camel case and dashes\n//   e.g. example-componentOne\n// - Could give incorrect results in case where two components have names that\n//   only differ by their casing.\n//   e.g. example-component-two & exampleComponentTwo\nvar styleParse = function styleParse(value) {\n\n  function dashLowerCase(str) {\n    return '-' + str[0].toLowerCase();\n  }\n\n  function fromCamelCase(str) {\n    return str.replace(/([A-Z])/g, dashLowerCase);\n  }\n\n  var data = AFRAME.utils.styleParser.parse(value);\n\n  var key;\n  var component;\n  var remainder;\n  var dashComponent;\n  var dashKey;\n\n  for (key in data) {\n    component = key.split('.')[0];\n    remainder = key.split('.').slice(1).join('.');\n    dashComponent = fromCamelCase(component);\n    if (component === dashComponent) {\n      continue;\n    }\n\n    if (AFRAME.components[dashComponent] && !AFRAME.components[component]) {\n      dashKey = dashComponent.concat('.', remainder);\n      data[dashKey] = data[key];\n      delete data[key];\n    }\n  }\n\n  return data;\n};\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\nmodule.exports =  AFRAME.registerComponent('event-set', {\n  schema: {\n    default: '',\n    parse: function (value) {\n        console.log(\"value: \", value);\n        let r = styleParse(value);\n        console.log(\"parsed: \", r)\n      return r;\n    },\n    stringify: function (data) {\n        console.log(\"stringify: \",data);\n      return styleParser.stringify(data);\n    },\n  },\n\n  multiple: true,\n\n  init: function () {\n    this.eventHandler = null;\n    this.eventName = null;\n  },\n\n  update: function (oldData) {\n    this.removeEventListener();\n    this.updateEventListener();\n    this.addEventListener();\n  },\n\n  pause: function () {\n    this.removeEventListener();\n  },\n\n  play: function () {\n    this.addEventListener();\n  },\n\n  /**\n   * Update source-of-truth event listener registry.\n   * Does not actually attach event listeners yet.\n   */\n  updateEventListener: function () {\n    var data = this.data;\n    var el = this.el;\n    var event;\n    var target;\n    var targetEl;\n\n    // Set event listener using `_event`.\n    event = data._event || this.id;\n    target = data._target;\n\n    // Decide the target to `setAttribute` on.\n    targetEl = target ? el.sceneEl.querySelector(target) : el;\n\n    this.eventName = event;\n\n    const handler = () => {\n      var propName;\n      // Set attributes.\n      for (propName in data) {\n        if (propName === '_event' || propName === '_target') { continue; }\n        AFRAME.utils.entity.setComponentProperty.call(this, targetEl, propName,\n                                                      data[propName]);\n      }\n    };\n\n    if (!isNaN(data._delay)) {\n      // Delay.\n      this.eventHandler = () => { setTimeout(handler, parseFloat(data._delay)); };\n    } else {\n      this.eventHandler = handler;\n    }\n  },\n\n  addEventListener: function () {\n    this.el.addEventListener(this.eventName, this.eventHandler);\n  },\n\n  removeEventListener: function () {\n    this.el.removeEventListener(this.eventName, this.eventHandler);\n  }\n});","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","require('./new-event-set');\n"],"names":[],"sourceRoot":""}